## 事件循环


### 浏览器的进程模型

- 何为进程?

  - 程序运行都有它专属的**内存空间**，而这块内存空间可以理解为**进程**
  - 每个应用程序至少有一个进程，进程之间相互***独立***，即使通信，也需要双方同意

    > 进程的设计就是为了相互隔离 ，这样就算某进程中程序出问题，也不会影响其他进程程序
    >
- 何为线程？

  > 有了进程（就是有了内存空间）后，程序就可以跑了
  >
  > 而运行代码的“人”称为“线程”

  - 一个进程至少有一个线程（进程开启后***自动***创建一个线程来运行代码，该线程称为***主线程***）

    > PS：若主线程结束了，整个程序就结束了；线程共享了内存不会相互隔离

  - 程序需要同时执行多块代码，主线程就会启动更多的线程来共同执行代码，所以一个进程中可以包含多个线程

    <img src="C:/Desktop/everyday-study/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/images/image-20230425230843969.png" alt="image-20230425230843969" style="zoom: 80%;" />

- 浏览器有哪些进程和线程？

  - 浏览器是有多个进程和线程的应用程序

  - 浏览器工作及其复杂；为避免相互影响，减少连环崩溃的几率，启动浏览器后会自动启动多个进程

  - 主要有浏览器进程、网络进程、渲染进程

    > 可以在`浏览器->更多工具->任务管理器`中查看浏览器当前所有进程

    1. 浏览器进程：

       - 负责界面展示（网页标题，前进后退刷新那些）用户交互、子进程管理（网络进程、渲染进程等都是它开的）浏览器进程内部启动了多个线程处理不同的任务

    2. 网络进程

       - 加载网络资源，内部启动了多个线程处理不同的网络任务

    3. ***渲染进程*** ***

       - 渲染进程开启后，自动启动一个***渲染主线程***，主要负责执行HTML、CSS、JS代码

       - 默认，浏览器为每一个新标签页开一个***新的渲染进程***（保障不容标签页之前的隔离性）

         > 浏览器已经想改变这种模式了，因为这样占用的内存太多了



### 渲染主线程如何工作？

- 它是浏览器中最繁忙的线程，需要它处理

  - 解析HTML
  - 解析CSS
  - 计算样式
  - 布局
  - 处理图层
  - 每秒将页面画60次
  - 执行JS全局代码
  - 执行事件处理函数
  - 执行计时器的回调函数
  - ...

  > 为何渲染进程不适用多个线程来处理这些事情？？？

- 主线程如何调度这么多任务？

  - 排队（事件循环，也称消息循环）

    1. 首先，渲染主线程会进入一个无限循环

    2. 每次循环都去检查消息队列是否有任务

       有任务，取出并执行***第一个任务***，任务执行完后进入下次循环

       无任务，渲染主线程进入休眠状态

    3. 其他所有线程（包括其他进程中的线程）都可以随时往消息队列添加任务。

       新任务都会添加到消息队列末尾

       添加任务时，若渲染主线程是休眠状态，会将其唤醒继续循环拿取任务





### 何为异步？

[^图片]: 图03-浏览器同步执行”异步代码

![image-20230429133557732](C:/Desktop/everyday-study/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/images/image-20230429133557732.png)

- 代码执行过程中，遇到的一些无法立即处理的任务：
  - 计时器类：setTimeout、setInterval
  - 网络通信类：XHR、Fetch
  - 用户操作类：addEventListener

> 若让渲染主线程等待这些任务执行，就会造成主线程长期处于"阻塞"状态（这就是同步处理哪些异步任务的后果），导致浏览器"卡死"

***渲染线程承担着及其重要的任务，无论如何都不能阻塞！！！***

- so，浏览器选择了异步处理上述任务



### 任务的优先级？？

- 任务没有优先级，在消息队列中先进先出、
- 但是，消息队列是有优先级的

> W3C最新的解释：
>
> - 每个任务都要有个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。
> - 浏览器必须有一个微队列，微队列中的任务优先所有其他任务执行。
> - 浏览器复杂度急剧提升，W3C不采用宏队列的说法。

- 目前chrome浏览器中，至少包含以下常见队列
  - 延时队列：用于存放计时器的回调任务，优先级<中>
  - 交互队列：用于存放用户操作后产生的事件处理任务，优先级<高>
  - 微队列：用于存放需要最快执行的任务，优先级<最高>









## 面试题

### 如何理解JS的异步？

1. **JS语言特性：单线程**

​		JS是一门单线程的语言。因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。

2. **为何要使用异步？**

​		而渲染主线程承担着诸多的工作，渲染页面、执行JS都是在其中运行。如果使用同步方式，就极有可能导致渲染主线程的阻塞，从而导致消息队列中很多其他任务无法执行。如此依赖，一方面会导致繁忙的主线程白白浪费时间，另一方面导致页面无法及时更新，给用户造成卡死现象。

​		所以浏览器采用异步的方式类避免。

3. **异步的具体实现**

   具体做法是当某些任务发生时（比如：计时器、网络、事件监听），主线程将任务交由其他线程取处理，自身立即结束任务执行，转而取执行后续代码。

   当其他线程完成时，将事件先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。

   异步模式下，浏览器永不阻塞，最大保障了单线程的流畅运行。



### 阐述一下JS的事件循环

1. 事件循环又叫消息循环，是浏览器渲染主线程的工作方式
2. 在chrome源码中，它开启一个不会结束的for循环，每次循环都会从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。
3. 过去将消息简单分成宏队列和微队列，这种说法目前已经无法满足浏览器环境，取而代之的是一种更加灵活多变的处理方式
4. W3C最新的解释：每个任务都要有个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。浏览器必须有一个微队列，微队列中的任务优先所有其他任务执行。



### JS中计时器能做到精确计时吗？

- 不能

1. 计算机硬件中没有原子钟，无法精确计时
2. 操作系统中的计时函数会有少量偏差，由于JS的计时器调用的是操作系统的函数，也就携带了这些偏差
3. 按照W3C的标准，浏览器实现计时器时，如果嵌套层级超过5层，就会带有4毫秒的最少时间，这样在计时时间少于4毫秒时又带来了偏差
4. 受事件循环的影响，计时器的回调只能在主线程空闲时运行，因此又带来了偏差
